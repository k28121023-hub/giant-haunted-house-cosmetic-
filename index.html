<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>å‹‡è€…é—–å·¨å¤§åŒ–é¬¼å±‹ï¼šHaunted Lexicon</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    body {
      background: #000;
      color: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      /* ä½¿ç”¨ dvh é¿å…æ‰‹æ©Ÿç€è¦½å™¨å·¥å…·åˆ—é®æ“‹ï¼Œfallback ç‚º 100vh */
      height: 100vh;
      height: 100dvh;
      overflow: hidden; /* ç¦æ­¢æ²å‹• */
      padding: 0;
      margin: 0;
    }

    .game-shell {
      width: 100%;
      height: 100%;
      position: relative;
      background: radial-gradient(circle at center, #1a1e29, #000 80%);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* éŠæˆ²ç•«å¸ƒï¼šä¿æŒæ¯”ä¾‹ï¼Œæœ€å¤§åŒ–é¡¯ç¤º */
    canvas {
      display: block;
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      aspect-ratio: 900 / 560;
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
      cursor: crosshair;
      /* ç¢ºä¿ç•«å¸ƒåœ¨æ­£ä¸­é–“ */
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1;
    }

    /* === HUD (æŠ¬é ­é¡¯ç¤ºå™¨) - éŠæˆ²ä¸­é¡¯ç¤º === */
    #hud-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ° Canvas */
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .hud-top-bar {
      background: linear-gradient(to bottom, rgba(0,0,0,0.9), rgba(0,0,0,0));
      padding: 10px 20px 40px 20px;
      text-align: center;
      pointer-events: auto;
    }

    #current-question-text {
      font-size: 24px;
      font-weight: bold;
      color: #ffd700;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8);
      margin: 4px 0;
    }

    #instruction-sub {
      font-size: 14px;
      color: #a0aaff;
      opacity: 0.9;
    }

    .status-badges {
      display: inline-flex;
      gap: 10px;
      margin-top: 4px;
      font-size: 12px;
      color: #ccc;
      background: rgba(0,0,0,0.3);
      padding: 4px 8px;
      border-radius: 12px;
    }

    /* === é¸å–®è¦†è“‹å±¤ (Menu Overlay) - é–‹å§‹/æš«åœ/çµæŸæ™‚é¡¯ç¤º === */
    #menu-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 20;
      background: rgba(10, 12, 20, 0.85);
      backdrop-filter: blur(5px);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      transition: opacity 0.3s ease;
    }

    /* ç•¶éŠæˆ²é€²è¡Œæ™‚éš±è—é¸å–® */
    #menu-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .menu-card {
      background: rgba(30, 35, 50, 0.95);
      padding: 24px;
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 20px 50px rgba(0,0,0,0.7);
      max-width: 90%;
      width: 400px;
    }

    .menu-title h1 {
      font-size: 28px;
      margin: 0;
      color: #fff;
      letter-spacing: 2px;
    }
    .menu-title .subtitle {
      color: #b6c1ff;
      font-size: 14px;
      margin-bottom: 16px;
    }

    #message {
      font-size: 15px;
      color: #e0e6ff;
      margin-bottom: 20px;
      line-height: 1.5;
      min-height: 24px;
    }

    #startBtn {
      width: 100%;
      padding: 16px;
      font-size: 18px;
      font-weight: bold;
      border-radius: 50px;
      border: none;
      background: linear-gradient(135deg, #5c7cff, #9f6bff);
      color: #fff;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(92, 124, 255, 0.4);
      transition: transform 0.1s ease;
    }
    #startBtn:active { transform: scale(0.96); }

    .legend {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-top: 16px;
      font-size: 12px;
      color: #aaa;
    }
    .legend-item { display: flex; align-items: center; gap: 4px; }
    .dot { width: 8px; height: 8px; border-radius: 50%; }

    /* === æ‰‹æ©Ÿå°ˆç”¨å°„æ“ŠæŒ‰éˆ• (Floating Action Button) === */
    #mobile-controls {
      position: absolute;
      /* ç¢ºä¿è·é›¢é‚Šç·£è¶³å¤ é ï¼Œé¿å…è¢«åˆ‡åˆ° */
      bottom: 60px; 
      right: 40px;
      z-index: 30; /* æœ€é«˜å±¤ç´š */
    }

    #mobileFireBtn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(255, 215, 0, 0.4); /* ç¨å¾®å¢åŠ ä¸é€æ˜åº¦ */
      border: 4px solid #ffd700;
      color: #ffd700;
      font-size: 32px;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0 0 25px rgba(255, 215, 0, 0.6);
      backdrop-filter: blur(2px);
      transition: all 0.1s;
      user-select: none;
      touch-action: none; 
    }

    #mobileFireBtn:active {
      background: rgba(255, 215, 0, 0.8);
      color: #fff;
      transform: scale(0.92);
    }

    /* æ‰‹æ©Ÿç›´å¼å„ªåŒ– */
    @media (max-width: 600px) {
      #current-question-text { font-size: 20px; }
      .hud-top-bar { padding: 10px 10px 30px 10px; }
      /* æ‰‹æ©Ÿç‰ˆæŒ‰éˆ•ä½ç½®å„ªåŒ– */
      #mobile-controls { bottom: 50px; right: 30px; }
      #mobileFireBtn { width: 75px; height: 75px; font-size: 28px; }
      canvas { width: 100%; height: auto; }
    }
  </style>
</head>
<body>
  <div class="game-shell">
    
    <!-- éŠæˆ²ç•«å¸ƒ -->
    <canvas id="gameCanvas" width="900" height="560"></canvas>

    <!-- HUD å±¤ (éŠæˆ²ä¸­å¸¸é§é¡¯ç¤º) -->
    <div id="hud-layer">
      <div class="hud-top-bar">
        <div id="instruction-sub">ä»»å‹™ç›®æ¨™ï¼šæ¥ä½æ­£ç¢ºç­”æ¡ˆ</div>
        <div id="current-question-text">æº–å‚™é–‹å§‹</div>
        <div class="status-badges">
          <span id="levelLabel">Level 1</span>
          <span>|</span>
          <span id="progressLabel">0/10</span>
        </div>
      </div>
      <!-- åº•éƒ¨ä¿ç•™ç©ºé–“çµ¦å°„æ“ŠæŒ‰éˆ• -->
    </div>

    <!-- é¸å–®å±¤ (é–‹å§‹/æš«åœ/çµæŸ) -->
    <div id="menu-overlay">
      <div class="menu-card">
        <div class="menu-title">
          <h1>å‹‡è€…é—–å·¨å¤§åŒ–é¬¼å±‹</h1>
          <div class="subtitle">Haunted Lexicon</div>
        </div>
        
        <div id="message">æŒ‰ä¸‹é–‹å§‹ï¼Œæ¥ä½æ­£ç¢ºå–®å­—ï¼Œç™¼å°„é­”æ³•å…‰æ³¢ï¼</div>
        
        <button id="startBtn">é–‹å§‹æŒ‘æˆ°</button>
        
        <div class="legend">
           <div class="legend-item"><div class="dot" style="background:#fff; border:1px solid #aaa"></div>æ¥æ­£ç¢ºå­—</div>
           <div class="legend-item"><div class="dot" style="background:#ff4d4d"></div>å°„æ“Šç«çƒ</div>
           <div class="legend-item"><div class="dot" style="background:#c0d4ff"></div>å°„æ“Šå¹½éˆ</div>
        </div>
        <div style="font-size:12px; color:#666; margin-top:10px;">(é›»è…¦æŒ‰ç©ºç™½éµ / æ‰‹æ©ŸæŒ‰å³ä¸‹è§’)</div>
      </div>
    </div>

    <!-- æ‡¸æµ®æ“ä½œæŒ‰éˆ• -->
    <div id="mobile-controls">
      <div id="mobileFireBtn">ğŸ¹</div>
    </div>

  </div>

  <script>
    // ====== åŸºæœ¬è¨­å®š ======
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const messageEl = document.getElementById("message");
    const questionTextEl = document.getElementById("current-question-text");
    const instructionSubEl = document.getElementById("instruction-sub");
    const startBtn = document.getElementById("startBtn");
    const levelLabel = document.getElementById("levelLabel");
    const progressLabel = document.getElementById("progressLabel");
    const mobileFireBtn = document.getElementById("mobileFireBtn");
    const menuOverlay = document.getElementById("menu-overlay");

    let WIDTH = 900;
    let HEIGHT = 560;

    // ====== åœ–ç‰‡è³‡æºè¨­å®š (å¯æ›¿æ›) ======
    const imagePaths = {
      player: "shooter.png", 
      ghost: "ghost.png",  
      boss: "king.png",
      santa: "santa.png" 
    };

    const defaultSvg = {
      player: "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cpath fill='%235c7cff' d='M32 2L10 20v40h44V20L32 2z'/%3E%3Ccircle cx='32' cy='28' r='10' fill='%23f8e0c8'/%3E%3Cpath fill='%238a2be2' d='M32 2L16 20h32L32 2z'/%3E%3Cpath stroke='%23ffd700' stroke-width='3' d='M44 36l12-8M44 36l12 8'/%3E%3C/svg%3E",
      ghost: "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cpath fill='%23c0d4ff' d='M32 2C15.4 2 2 15.4 2 32v20l10-6 10 6 10-6 10 6 10-6 10 6V32c0-16.6-13.4-30-30-30z' opacity='0.9'/%3E%3Ccircle cx='22' cy='24' r='4' fill='%2327304a'/%3E%3Ccircle cx='42' cy='24' r='4' fill='%2327304a'/%3E%3C/svg%3E",
      boss: "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='45' fill='%23ff3333'/%3E%3Cpath fill='%23ffd700' d='M20 30l10-20 20 15 20-15 10 20z'/%3E%3Ccircle cx='35' cy='55' r='6' fill='%2300ffff'/%3E%3Ccircle cx='65' cy='55' r='6' fill='%2300ffff'/%3E%3Cpath stroke='%23330000' stroke-width='4' fill='none' d='M30 75q20 15 40 0'/%3E%3C/svg%3E",
      santa: "data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 60'%3E%3C!-- Runners --%3E%3Cpath d='M10,50 L110,50' stroke='%23C0C0C0' stroke-width='3'/%3E%3Cpath d='M10,50 Q5,40 15,40' stroke='%23C0C0C0' stroke-width='3' fill='none'/%3E%3C!-- Sleigh Body --%3E%3Cpath d='M20,45 L100,45 Q110,45 110,35 L100,25 L30,25 Q20,25 20,45 Z' fill='%23cc0000'/%3E%3C!-- Gold Trim --%3E%3Cpath d='M20,30 L100,30' stroke='%23ffd700' stroke-width='2'/%3E%3C!-- Bag --%3E%3Ccircle cx='40' cy='20' r='14' fill='%238B4513'/%3E%3C!-- Santa Body --%3E%3Ccircle cx='80' cy='25' r='12' fill='%23cc0000'/%3E%3C!-- Santa Head --%3E%3Ccircle cx='80' cy='15' r='8' fill='%23ffe0bd'/%3E%3C!-- Hat --%3E%3Cpath d='M72,12 Q80,-5 88,12' fill='%23cc0000'/%3E%3Ccircle cx='88' cy='12' r='3' fill='white'/%3E%3C!-- Beard --%3E%3Cpath d='M74,18 Q80,28 86,18' fill='white'/%3E%3C/svg%3E"
    };

    const assets = {
      player: new Image(),
      ghost: new Image(), 
      boss: new Image(),
      santa: new Image()
    };

    function loadGameImages() {
      assets.player.onerror = () => { assets.player.src = defaultSvg.player; };
      assets.player.src = imagePaths.player;

      assets.ghost.onerror = () => { assets.ghost.src = defaultSvg.ghost; };
      assets.ghost.src = imagePaths.ghost;

      assets.boss.onerror = () => { assets.boss.src = defaultSvg.boss; };
      assets.boss.src = imagePaths.boss;

      assets.santa.onerror = () => { assets.santa.src = defaultSvg.santa; };
      assets.santa.src = imagePaths.santa;
    }

    loadGameImages();

    // ====== é¡Œåº« ======
    
    // ç¬¬ä¸€é—œï¼šæœé£¾èˆ‡é…ä»¶
    const vocabQuestions = [
      { zh: "çŸ­è¡£", en: "T-shirt", options: ["T-shirt", "shirt", "short", "sheet"] },
      { zh: "æ´‹è£", en: "dress", options: ["dress", "desk", "press", "address"] },
      { zh: "ç‰›ä»”è¤²", en: "jeans", options: ["jeans", "beans", "means", "teens"] },
      { zh: "é•·è¤²", en: "pants", options: ["pants", "plants", "plans", "pain"] },
      { zh: "è¥¯è¡«", en: "shirt", options: ["shirt", "skirt", "short", "shift"] },
      { zh: "çš®å¸¶", en: "belt", options: ["belt", "bell", "felt", "bolt"] },
      { zh: "æ­£è£é‹", en: "dress shoes", options: ["dress shoes", "sneakers", "boots", "sandals"] },
      { zh: "é ˜å¸¶", en: "tie", options: ["tie", "pie", "lie", "die"] }, 
      { zh: "å¤¾å…‹", en: "jacket", options: ["jacket", "pocket", "rocket", "packet"] },
      { zh: "æ¯›è¡£", en: "sweater", options: ["sweater", "weather", "better", "water"] },
      { zh: "é´å­", en: "boots", options: ["boots", "boats", "books", "roots"] },
      { zh: "ç„¡è¢–ä¸Šè¡£", en: "tank top", options: ["tank top", "laptop", "rooftop", "tip top"] },
      { zh: "çŸ­è¤²", en: "shorts", options: ["shorts", "sports", "sorts", "shirts"] },
      { zh: "å¥³ç”¨å¥—è£", en: "blouse", options: ["blouse", "mouse", "house", "browse"] },
      { zh: "è£™å­", en: "skirt", options: ["skirt", "shirt", "skin", "skill"] },
      { zh: "è¥¿è£", en: "suit", options: ["suit", "fruit", "seat", "salt"] },
      { zh: "æ¶¼é‹", en: "sandals", options: ["sandals", "candles", "vandals", "handles"] },
    ];

    // ç¬¬äºŒé—œï¼šè¡£æœç›¸é—œè©å½™
    const level2Questions = [
      { zh: "è¡£æœ", en: "outfit", options: ["outfit", "outside", "output", "outlet"] },
      { zh: "å“ç‰Œ", en: "brand", options: ["brand", "band", "grand", "blend"] },
      { zh: "æœ€æ–°çš„", en: "latest", options: ["latest", "late", "last", "least"] },
      { zh: "è©¦ç©¿", en: "try on", options: ["try on", "put on", "take off", "turn on"] },
      { zh: "åˆèº«", en: "fit", options: ["fit", "fat", "bit", "hit"] },
      { zh: "å®Œç¾åœ°", en: "perfectly", options: ["perfectly", "perfect", "partly", "plainly"] },
      { zh: "æ…¢è·‘", en: "jog", options: ["jog", "job", "dog", "log"] },
      { zh: "é¬†çš„", en: "loose", options: ["loose", "lose", "lost", "goose"] },
    ];

    // ====== éŠæˆ²ç‹€æ…‹ ======
    const game = {
      state: "menu", // menu, level1, level2, gameOver, victory
      level: 0,
      hp: 5,
      maxHp: 5,
      ghosts: [],
      wordProjectiles: [], 
      attackProjectiles: [], 
      playerArrows: [], 
      goldenWaves: [], 
      effects: [], 
      player: null,
      boss: null,
      currentQuestions: [],
      currentIndex: 0,
      lastTime: 0,
      hitEffectTime: 0,
      flashTime: 0,
      touchTarget: null,
      wordSpawnTimer: 0,
      attackSpawnTimer: 0,
      ghostSpawnTimer: 0, 
    };

    // ====== å·¥å…·å‡½æ•¸ ======
    function randRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    function shuffleArray(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // ====== ç‰©ä»¶å‰µå»º ======
    function createPlayer() {
      return {
        x: WIDTH * 0.1,
        y: HEIGHT * 0.5,
        w: 80, 
        h: 80, 
        speed: 280,
        vx: 0,
        vy: 0,
        attackCooldown: 0
      };
    }

    function createGhost(isBossMinion = false) {
      const x = randRange(WIDTH * 0.5, WIDTH - 50);
      const y = randRange(60, HEIGHT - 60);
      return {
        x,
        y,
        r: 35, 
        vx: randRange(-30, 30),
        vy: randRange(-30, 30),
        alpha: randRange(0.8, 1.0),
        wobble: Math.random() * Math.PI * 2,
        isBossMinion: isBossMinion,
        attackCooldown: 0, 
        hitFlash: 0,
        hp: 1 // [æ–°å¢] å¹½éˆæœ‰ HPï¼Œåˆå§‹ç‚º 1
      };
    }

    function createBoss() {
      const bossHp = level2Questions.length; // Boss è¡€é‡ç­‰æ–¼é¡Œç›®æ•¸é‡
      return {
        x: WIDTH * 0.85,
        y: HEIGHT * 0.5,
        r: 140, 
        vx: 0,
        vy: 120,
        maxHp: bossHp,
        hp: bossHp,
        attackCooldown: 1.5,
        hitFlash: 0
      };
    }

    function createPlayerArrow(x, y) {
      return {
        x: x,
        y: y,
        vx: 600, 
        vy: 0,
        w: 50, 
        h: 6,
        life: 2.0
      };
    }

    function createGoldenWave(x, y, targetX, targetY) {
      const angle = Math.atan2(targetY - y, targetX - x);
      return {
        x: x,
        y: y,
        speed: 600, 
        vx: Math.cos(angle) * 600, 
        vy: Math.sin(angle) * 600,
        r: 30, 
        angle: angle,
        life: 5.0, 
        homing: true 
      };
    }

    function createEffect(x, y, color, size = 25) {
      return {
        x, y, color,
        r: 2,
        maxR: size,
        alpha: 1.0,
        life: 0.4
      };
    }

    function createWordProjectile(sourceX, sourceY, targetX, targetY, text, isCorrect) {
        const angle = Math.atan2(targetY - sourceY, targetX - sourceX);
        const speed = isCorrect ? 160 : 200; 
        
        const baseRadius = 32; 
        const charWidthApprox = 14; 
        const textWidth = text.length * charWidthApprox;
        const radius = Math.max(baseRadius, (textWidth / 2) + 16);

        return {
            x: sourceX,
            y: sourceY,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            text: text,
            isCorrect: isCorrect,
            r: radius,
            life: 6.0, 
            type: 'word'
        };
    }

    // [æ–°å¢] çµ±ä¸€è™•ç†ç­”å°é‚è¼¯ (ä¸ç®¡æ˜¯æ¥ä½é‚„æ˜¯å°„ä¸­)
    function triggerCorrectAnswer(sourceX, sourceY) {
        game.flashTime = 0.2;
        game.currentIndex++;
        game.wordProjectiles = []; // æ¸…é™¤å ´ä¸Šæ‰€æœ‰å–®å­—

        // å¦‚æœæ˜¯ç¬¬äºŒé—œ Boss æˆ°ï¼Œç”¢ç”Ÿæ”»æ“Š Boss çš„å…‰æ³¢
        if (game.level === 2 && game.boss) {
             game.goldenWaves.push(createGoldenWave(sourceX, sourceY, game.boss.x, game.boss.y));
        }
        
        // æª¢æŸ¥æ˜¯å¦éé—œ
        if (game.currentIndex >= game.currentQuestions.length) {
            if (game.level === 1) {
                setTimeout(startLevel2, 500); 
            } else {
                messageEl.textContent = "æœ€å¾Œä¸€æ“Šç™¼å°„ï¼";
            }
        } else {
            updateQuestionDisplay();
            updateUI("Nice! ä¸‹ä¸€é¡Œï¼", game.level === 1 ? "é—œå¡ 1" : "é—œå¡ 2", `${game.currentIndex} / ${game.currentQuestions.length}`);
        }
    }

    // [ä¿®å¾©] ä¹‹å‰éºå¤±çš„ createAttackProjectile å‡½æ•¸
    function createAttackProjectile(sourceX, sourceY, targetX, targetY, type) {
        const angle = Math.atan2(targetY - sourceY, targetX - sourceX);
        let speed, r, color;
        
        if (type === 'fire') {
            speed = 350;
            r = 12;
            color = '#ff4d4d'; 
        } else if (type === 'beam') {
            speed = 450;
            r = 18;
            color = '#4da6ff'; 
        }

        return {
            x: sourceX,
            y: sourceY,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            r: r,
            life: 3.0,
            type: type,
            color: color,
            rotation: angle
        };
    }

    // ====== è¼¸å…¥æ§åˆ¶ ======
    const keys = {};
    window.addEventListener("keydown", (e) => {
      if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight", " "].indexOf(e.key) > -1) {
        if (game.state === "level1" || game.state === "level2") e.preventDefault();
      }
      keys[e.key] = true;
      
      if (e.key === " " && (game.state === "level1" || game.state === "level2")) {
        tryShoot();
      }
      game.touchTarget = null;
    });
    window.addEventListener("keyup", (e) => keys[e.key] = false);

    function tryShoot() {
        if (!game.player) return;
        if (game.player.attackCooldown <= 0) {
            game.playerArrows.push(createPlayerArrow(game.player.x + 20, game.player.y));
            game.player.attackCooldown = 0.35; 
            game.player.x = Math.max(30, game.player.x - 5);
        }
    }

    // æ‰‹æ©Ÿå°„æ“ŠæŒ‰éˆ•æ§åˆ¶
    mobileFireBtn.addEventListener("touchstart", (e) => {
      e.preventDefault(); 
      tryShoot();
      mobileFireBtn.style.transform = "scale(0.9)";
      mobileFireBtn.style.background = "rgba(255, 215, 0, 0.8)";
    }, {passive: false});

    mobileFireBtn.addEventListener("touchend", (e) => {
      e.preventDefault();
      mobileFireBtn.style.transform = "scale(1)";
      mobileFireBtn.style.background = "rgba(255, 215, 0, 0.5)";
    }, {passive: false});


    function handleTouch(e) {
      if (game.state !== "level1" && game.state !== "level2") return;
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const touch = e.touches[0];
      game.touchTarget = {
        x: (touch.clientX - rect.left) * scaleX,
        y: (touch.clientY - rect.top) * scaleY
      };
    }
    canvas.addEventListener("touchstart", handleTouch, {passive: false});
    canvas.addEventListener("touchmove", handleTouch, {passive: false});
    canvas.addEventListener("touchend", (e) => {
      e.preventDefault();
      game.touchTarget = null;
    });

    // ====== éŠæˆ²æµç¨‹æ§åˆ¶ ======
    startBtn.addEventListener("click", () => {
      startLevel1();
    });

    function toggleMenu(show) {
      if(show) {
        menuOverlay.classList.remove('hidden');
      } else {
        menuOverlay.classList.add('hidden');
      }
    }

    function startLevel1() {
      toggleMenu(false);
      game.state = "level1";
      game.level = 1;
      game.hp = 5;
      game.maxHp = 5;
      game.player = createPlayer();
      game.ghosts = [];
      game.wordProjectiles = [];
      game.attackProjectiles = [];
      game.playerArrows = [];
      game.goldenWaves = [];
      game.effects = [];
      for (let i = 0; i < 5; i++) game.ghosts.push(createGhost());
      game.boss = null;
      game.currentQuestions = shuffleArray(vocabQuestions);
      game.currentIndex = 0;
      game.wordSpawnTimer = 0;
      game.ghostSpawnTimer = 0;
      
      updateQuestionDisplay();
      updateUI("Level 1ï¼šæŒ‰ç©ºç™½éµ(Space)å°„æ“Šï¼", "Level 1", `1 / ${game.currentQuestions.length}`);
    }

    function startLevel2() {
      game.state = "level2";
      game.level = 2;
      game.hp = game.maxHp; 
      game.player = createPlayer();
      game.ghosts = [];
      game.wordProjectiles = [];
      game.attackProjectiles = [];
      game.playerArrows = [];
      game.goldenWaves = [];
      game.effects = [];
      for (let i = 0; i < 2; i++) game.ghosts.push(createGhost(true));
      game.boss = createBoss();
      game.currentQuestions = shuffleArray(level2Questions);
      game.currentIndex = 0;
      game.wordSpawnTimer = 0;
      game.ghostSpawnTimer = 0;

      updateQuestionDisplay();
      updateUI("Level 2 BOSSï¼šæ¥ä½æ­£ç¢ºå–®å­—ç™¼å°„å…‰æ³¢ï¼", "Level 2 BOSS", `1 / ${game.currentQuestions.length}`);
    }

    function updateQuestionDisplay() {
        if(game.currentIndex >= game.currentQuestions.length) return;
        
        const q = game.currentQuestions[game.currentIndex];
        
        // [ä¿®æ”¹] æ›´æ–°æç¤ºæ–‡å­—ï¼Œå¼·èª¿å¿…é ˆå°„æ“Š
        instructionSubEl.textContent = "ä»»å‹™ï¼šå°„æ“Šæ­£ç¢ºç­”æ¡ˆ (èº«é«”è§¸ç¢°ç„¡æ•ˆ)";
        questionTextEl.textContent = q.zh;
        
        questionTextEl.style.animation = "none";
        questionTextEl.offsetHeight; 
        questionTextEl.style.animation = "pulseText 0.5s";
    }

    function updateUI(msg, lvl, prog) {
        messageEl.textContent = msg;
        levelLabel.textContent = lvl;
        progressLabel.textContent = prog;
    }

    function gameOver() {
        game.state = "gameOver";
        toggleMenu(true);
        messageEl.textContent = "ğŸ’€ æŒ‘æˆ°å¤±æ•—ï¼ä½ çš„ç²¾ç¥åŠ›è€—ç›¡äº†...";
        startBtn.textContent = "å†è©¦ä¸€æ¬¡";
    }

    function victory() {
        game.state = "victory";
        toggleMenu(true);
        messageEl.textContent = "ğŸ† æ­å–œï¼é­”ç‹å·²æ•—äº¡ï¼Œè³¢è€…ç²å¾—äº†æœ€çµ‚å‹åˆ©ï¼";
        startBtn.textContent = "å†æ¬¡æŒ‘æˆ°";
    }

    // ====== éŠæˆ²é‚è¼¯ ======
    function spawnWord() {
        if(game.currentIndex >= game.currentQuestions.length) return; 

        const q = game.currentQuestions[game.currentIndex];
        const isCorrectTarget = Math.random() < 0.5;
        let text = "";
        
        if (isCorrectTarget) {
            text = q.en; 
        } else {
            const correct = q.en;
            const wrongs = q.options.filter(o => o !== correct);
            text = wrongs[Math.floor(Math.random() * wrongs.length)];
        }

        // [ä¿®æ”¹] å–®å­—ä¸€å¾‹å¾å³å´è¢å¹•å¤–ç”Ÿæˆ
        const sourceX = WIDTH + 50;
        const sourceY = randRange(50, HEIGHT - 50);

        const targetX = game.player.x;
        const targetY = game.player.y + randRange(-50, 50);

        game.wordProjectiles.push(createWordProjectile(sourceX, sourceY, targetX, targetY, text, isCorrectTarget));
    }

    function respawnGhost() {
        setTimeout(() => {
            if (game.state === "level1" && game.ghosts.length < 5) {
                game.ghosts.push(createGhost());
            } else if (game.state === "level2" && game.ghosts.length < 3) {
                 game.ghosts.push(createGhost(true));
            }
        }, 1500);
    }

    function updateEnemies(dt) {
        const p = game.player;

        // 1. ç§»å‹•èˆ‡é‚Šç•Œåˆ¤å®š
        game.ghosts.forEach(g => {
            // [ä¿®æ”¹] å·¨å¤§åŒ–å¹½éˆçš„è¿½è¹¤é‚è¼¯
            if (g.r > 50) {
                // å¦‚æœåŠå¾‘å¤§æ–¼ 50 (è®Šå¤§äº†)ï¼Œé–‹å§‹è¿½è¹¤ç©å®¶
                const dx = p.x - g.x;
                const dy = p.y - g.y;
                const angle = Math.atan2(dy, dx);
                // é€Ÿåº¦ç¨æ…¢ï¼Œå½¢æˆå£“è¿«æ„Ÿ
                const speed = 45; 
                g.vx = Math.cos(angle) * speed;
                g.vy = Math.sin(angle) * speed;
            }

            g.x += g.vx * dt;
            g.y += g.vy * dt;
            
            // é‚Šç•Œåˆ¤å®šï¼šæ™®é€šå¹½éˆåœ¨å³å´åå½ˆï¼Œå·¨å¤§å¹½éˆå¯è·¨è¶Šä¸­ç·šé€¼è¿‘ç©å®¶
            if (g.r <= 50) {
                if(g.x < WIDTH * 0.4 || g.x > WIDTH - 30) g.vx *= -1;
                if(g.y < 30 || g.y > HEIGHT - 30) g.vy *= -1;
            } else {
                // å·¨å¤§å¹½éˆåªéœ€é™åˆ¶ä¸Šä¸‹é‚Šç•Œï¼Œå·¦å³ä¸é™åˆ¶è®“å…¶é€¼è¿‘
                if(g.y < g.r || g.y > HEIGHT - g.r) g.vy *= -1;
            }
            
            if (g.hitFlash > 0) g.hitFlash -= dt;
        });

        // [æ–°å¢] å¹½éˆèåˆæ©Ÿåˆ¶ï¼šè‹¥ç¢°åˆ°å½¼æ­¤ï¼Œåˆé«”è®Šå¤§
        for (let i = 0; i < game.ghosts.length; i++) {
            for (let j = i + 1; j < game.ghosts.length; j++) {
                const g1 = game.ghosts[i];
                const g2 = game.ghosts[j];
                
                const dx = g1.x - g2.x;
                const dy = g1.y - g2.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                // åˆ¤å®šå…©è€…æ¥è§¸ (åŠå¾‘ä¹‹å’Œ)
                if (dist < g1.r + g2.r) {
                    // è¨ˆç®—èåˆå¾Œçš„æ–°åŠå¾‘ (é¢ç©ç–ŠåŠ : r_new = sqrt(r1^2 + r2^2))
                    // è¨­å®šæœ€å¤§ä¸Šé™ r=110ï¼Œé¿å…å¤§åˆ°è¦†è“‹æ•´å€‹ç•«é¢
                    const newR = Math.min(110, Math.sqrt(g1.r * g1.r + g2.r * g2.r));
                    
                    // è®“ g1 è®Šå¤§ï¼Œä¸”è¡€é‡ç–ŠåŠ 
                    g1.r = newR;
                    g1.hp += g2.hp; 
                    
                    // ç¨å¾®æ¨ç§»ä½ç½®åˆ°å…©è€…ä¸­é–“ï¼Œè®“èåˆçœ‹èµ·ä¾†æ›´è‡ªç„¶
                    g1.x = (g1.x + g2.x) / 2;
                    g1.y = (g1.y + g2.y) / 2;
                    
                    // ç‰¹æ•ˆ
                    game.effects.push(createEffect(g1.x, g1.y, "#c0d4ff", newR * 1.5));

                    // ç§»é™¤ g2
                    game.ghosts.splice(j, 1);
                    j--; // å› é™£åˆ—é•·åº¦æ”¹è®Šï¼Œèª¿æ•´ç´¢å¼•
                }
            }
        }

        if (game.boss) {
            const b = game.boss;
            b.y += b.vy * dt;
            if (b.y < 80 || b.y > HEIGHT - 80) b.vy *= -1;

            b.attackCooldown -= dt;
            if (b.attackCooldown <= 0) {
                game.attackProjectiles.push(createAttackProjectile(b.x - 40, b.y, p.x, p.y, 'beam'));
                if(Math.random() < 0.35) {
                     setTimeout(() => {
                         if(game.state === 'level2' && game.boss && game.boss.hp > 0) 
                             game.attackProjectiles.push(createAttackProjectile(b.x - 40, b.y, p.x, p.y, 'beam'));
                     }, 200);
                }
                b.attackCooldown = randRange(1.2, 2.0);
            }
            if (b.hitFlash > 0) b.hitFlash -= dt;
        }
    }

    function handleCollision() {
        const p = game.player;
        if (!p) return;
        
        for (let i = game.playerArrows.length - 1; i >= 0; i--) {
            const arrow = game.playerArrows[i];
            let arrowHit = false;

            // æª¢æŸ¥ï¼šå…‰æŸ vs æ•µæ–¹å­å½ˆ
            for (let j = game.attackProjectiles.length - 1; j >= 0; j--) {
                const atk = game.attackProjectiles[j];
                const dx = arrow.x - atk.x;
                const dy = arrow.y - atk.y;
                if (Math.sqrt(dx*dx + dy*dy) < atk.r + 10) {
                    game.effects.push(createEffect(atk.x, atk.y, "#fff")); 
                    game.attackProjectiles.splice(j, 1);
                    arrowHit = true;
                    break;
                }
            }
            if (arrowHit) {
                game.playerArrows.splice(i, 1);
                continue;
            }

            // æª¢æŸ¥ï¼šå…‰æŸ vs å¹½éˆ (å¹½éˆæœƒé˜»æ“‹å…‰æŸ)
            for (let j = game.ghosts.length - 1; j >= 0; j--) {
                const g = game.ghosts[j];
                const dx = arrow.x - g.x;
                const dy = arrow.y - g.y;
                if (Math.sqrt(dx*dx + dy*dy) < g.r + 10) {
                    // [ä¿®æ”¹] æ“Šä¸­å¹½éˆæ™‚æ‰£è¡€ï¼Œè€Œéç›´æ¥æ¶ˆæ»…
                    game.effects.push(createEffect(g.x, g.y, "#ff3b30")); 
                    
                    g.hp--; // æ‰£ HP
                    g.hitFlash = 0.2; // å—å‚·é–ƒçˆ
                    arrowHit = true; // å…‰æŸè¢«æ¶ˆè€—

                    // åªæœ‰è¡€é‡æ­¸é›¶æ‰ç§»é™¤
                    if (g.hp <= 0) {
                        game.ghosts.splice(j, 1);
                        respawnGhost(); // ç«‹å³è£œå……ä¸€å€‹ï¼Œä¿æŒæ•¸é‡
                    } else {
                        // æ“Šé€€æ•ˆæœï¼šç¨å¾®å¾€å¾Œæ¨ä¸€é»
                        g.x += 15;
                    }
                    break;
                }
            }
            if (arrowHit) {
                game.playerArrows.splice(i, 1);
                continue;
            }

            // [ä¿®æ”¹] æª¢æŸ¥ï¼šå…‰æŸ vs å–®å­— (æ ¸å¿ƒç©æ³•é‚è¼¯ä¿®æ”¹)
            for (let j = game.wordProjectiles.length - 1; j >= 0; j--) {
                const w = game.wordProjectiles[j];
                const tipX = arrow.x + arrow.w;
                const tipY = arrow.y;
                const dx = tipX - w.x;
                const dy = tipY - w.y;
                
                if (Math.sqrt(dx*dx + dy*dy) < w.r + 20) {
                    game.effects.push(createEffect(w.x, w.y, "#ffffff", 50)); 
                    game.wordProjectiles.splice(j, 1);
                    arrowHit = true;
                    
                    if (w.isCorrect) {
                        // å°„ä¸­æ­£ç¢ºç­”æ¡ˆ -> è§¸ç™¼æˆåŠŸé‚è¼¯
                        triggerCorrectAnswer(w.x, w.y);
                    } else {
                        // [ä¿®æ”¹] å°„ä¸­éŒ¯èª¤ç­”æ¡ˆ -> æ‰£è¡€ï¼
                        game.hitEffectTime = 0.3;
                        game.hp--;
                        messageEl.textContent = "å°„éŒ¯äº†ï¼é€™æ˜¯éŒ¯èª¤çš„å–®å­—ï¼";
                        if(game.hp <= 0) gameOver();
                    }
                    break;
                }
            }
            if (arrowHit) {
                game.playerArrows.splice(i, 1);
                continue;
            }

            // æª¢æŸ¥ï¼šå…‰æŸ vs Boss
            if (game.boss) {
                const b = game.boss;
                const dx = arrow.x - b.x;
                const dy = arrow.y - b.y;
                if (Math.sqrt(dx*dx + dy*dy) < b.r + 5) {
                     b.hitFlash = 0.1;
                     game.effects.push(createEffect(arrow.x, arrow.y, "#ffff00"));
                     game.playerArrows.splice(i, 1);
                     continue;
                }
            }
        }

        for (const g of game.ghosts) {
            const dx = p.x - g.x;
            const dy = p.y - g.y;
            if(Math.sqrt(dx*dx + dy*dy) < g.r + 15) {
                game.hp -= 1;
                game.hitEffectTime = 0.3;
                g.vx = -g.vx; 
                g.x += 30; 
                if(game.hp <= 0) gameOver();
                return; 
            }
        }

        if (game.boss) {
            const b = game.boss;
            const dx = p.x - b.x;
            const dy = p.y - b.y;
            if(Math.sqrt(dx*dx + dy*dy) < b.r + 15) {
                game.hp -= 2;
                game.hitEffectTime = 0.4;
                p.x -= 60;
                if(game.hp <= 0) gameOver();
                return;
            }
        }

        // ç©å®¶èº«é«” vs å–®å­—çš„ç¢°æ’æª¢æ¸¬å·²ç§»é™¤

        for (let i = game.attackProjectiles.length - 1; i >= 0; i--) {
            const atk = game.attackProjectiles[i];
            const dx = p.x - atk.x;
            const dy = p.y - atk.y;
            if(Math.sqrt(dx*dx + dy*dy) < atk.r + 12) {
                game.attackProjectiles.splice(i, 1);
                game.hitEffectTime = 0.3;
                game.hp -= (atk.type === 'beam' ? 2 : 1);
                if(game.hp <= 0) gameOver();
                return;
            }
        }
    }

    function update(dt) {
        if (game.state !== "level1" && game.state !== "level2") return;

        game.wordSpawnTimer -= dt;
        const spawnInterval = game.level === 1 ? 1.4 : 1.2;
        if(game.wordSpawnTimer <= 0) {
            spawnWord();
            game.wordSpawnTimer = spawnInterval;
        }

        // [æ–°å¢] å¹½éˆè‡ªå‹•å¢ç”Ÿé‚è¼¯
        game.ghostSpawnTimer -= dt;
        if (game.ghostSpawnTimer <= 0) {
            // è¨­å®šå¹½éˆæœ€å¤§æ•¸é‡ä¸Šé™ï¼Œè®“å ´é¢æœ‰è¶³å¤ çš„é˜»ç¤™ä½†ä¸æœƒå®Œå…¨å´©æ½°
            const maxGhosts = game.level === 1 ? 8 : 12;
            if (game.ghosts.length < maxGhosts) {
                game.ghosts.push(createGhost(game.level === 2));
            }
            // æ¯ 1.2 ç§’æª¢æŸ¥ä¸¦ç”Ÿæˆä¸€æ¬¡
            game.ghostSpawnTimer = 1.2;
        }

        updateEnemies(dt);

        const p = game.player;
        if (p.attackCooldown > 0) p.attackCooldown -= dt;
        
        p.vx = 0; p.vy = 0;
        if (keys["ArrowLeft"]) p.vx = -p.speed;
        if (keys["ArrowRight"]) p.vx = p.speed;
        if (keys["ArrowUp"]) p.vy = -p.speed;
        if (keys["ArrowDown"]) p.vy = p.speed;

        if (game.touchTarget) {
            const dx = game.touchTarget.x - p.x;
            const dy = game.touchTarget.y - p.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 10) {
                p.vx = (dx / dist) * p.speed;
                p.vy = (dy / dist) * p.speed;
            }
        }
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.x = Math.max(30, Math.min(WIDTH - 30, p.x));
        p.y = Math.max(30, Math.min(HEIGHT - 30, p.y));

        for (let i = game.playerArrows.length - 1; i >= 0; i--) {
            const a = game.playerArrows[i];
            a.x += a.vx * dt;
            a.life -= dt;
            if(a.life <= 0 || a.x > WIDTH) game.playerArrows.splice(i, 1);
        }

        for (let i = game.goldenWaves.length - 1; i >= 0; i--) {
            const wave = game.goldenWaves[i];
            
            if (game.boss && game.boss.hp > 0) {
                const targetX = game.boss.x;
                const targetY = game.boss.y;
                const angleToBoss = Math.atan2(targetY - wave.y, targetX - wave.x);
                wave.vx = Math.cos(angleToBoss) * wave.speed;
                wave.vy = Math.sin(angleToBoss) * wave.speed;
                wave.angle = angleToBoss;
            }

            wave.x += wave.vx * dt;
            wave.y += wave.vy * dt;
            wave.life -= dt;

            if (game.boss && game.boss.hp > 0) {
                const b = game.boss;
                const dx = wave.x - b.x;
                const dy = wave.y - b.y;
                if (Math.sqrt(dx*dx + dy*dy) < b.r + wave.r) {
                    b.hp -= 1;
                    b.hitFlash = 0.2; 
                    game.effects.push(createEffect(b.x, b.y, "#ffd700", 80)); 
                    game.goldenWaves.splice(i, 1);

                    if (b.hp <= 0) {
                        game.boss = null; 
                        game.effects.push(createEffect(b.x, b.y, "#fff", 200)); 
                        setTimeout(victory, 1000);
                    }
                    continue;
                }
            }

            if(wave.life <= 0 || wave.x > WIDTH + 100) game.goldenWaves.splice(i, 1);
        }

        for (let i = game.effects.length - 1; i >= 0; i--) {
            const e = game.effects[i];
            e.r += 60 * dt; 
            e.alpha -= 2.0 * dt; 
            e.life -= dt;
            if(e.life <= 0) game.effects.splice(i, 1);
        }

        [game.wordProjectiles, game.attackProjectiles].forEach(arr => {
            for (let i = arr.length - 1; i >= 0; i--) {
                const prj = arr[i];
                prj.x += prj.vx * dt;
                prj.y += prj.vy * dt;
                prj.life -= dt;
                if(prj.life <= 0 || prj.x < -50 || prj.x > WIDTH + 50 || prj.y < -50 || prj.y > HEIGHT + 50) {
                    arr.splice(i, 1);
                }
            }
        });

        handleCollision();

        if (game.flashTime > 0) game.flashTime -= dt;
        if (game.hitEffectTime > 0) game.hitEffectTime -= dt;
    }

    // ====== ç¹ªåœ– ======
    function draw() {
        const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
        grad.addColorStop(0, "#141826");
        grad.addColorStop(1, "#05060b");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        // [æ–°å¢] è©­ç•°ç´…è‰²æœˆäº®
        ctx.save();
        ctx.fillStyle = "#ff3333"; 
        ctx.shadowBlur = 50;
        ctx.shadowColor = "#ff0000";
        ctx.beginPath();
        ctx.arc(WIDTH * 0.8, HEIGHT * 0.2, 50, 0, Math.PI * 2); 
        ctx.fill();
        ctx.restore();

        // è£é£¾
        ctx.fillStyle = "#1e2230";
        ctx.fillRect(WIDTH * 0.85, 80, 80, HEIGHT - 160);

        // [ä¿®æ”¹] ç©å®¶å°„æ“Šç‰¹æ•ˆ - ç§‘å¹»é›·é›»å…‰æŸ
        for (const a of game.playerArrows) {
            ctx.save();
            
            // 1. å¤–å±¤é›»å¼§ (ä¸»é–ƒé›»)
            ctx.shadowBlur = 20;
            ctx.shadowColor = "#00eaff"; 
            ctx.strokeStyle = "#ccf5ff";
            ctx.lineWidth = 3;
            ctx.lineJoin = "round";
            ctx.lineCap = "round";
            
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            
            let lx = a.x;
            let ly = a.y;
            const segments = 6; // å°‡å…‰æŸåˆ†ç‚ºå¹¾æ®µé–ƒé›»
            const step = a.w / segments;
            
            for(let k=0; k < segments; k++) {
                lx += step;
                // éš¨æ©Ÿ Y è»¸åç§»ï¼Œè£½é€ é›»æµè·³å‹•æ„Ÿ (æ¯ä¸€å¹€éƒ½æœƒè®Š)
                ly = a.y + (Math.random() - 0.5) * 20; 
                ctx.lineTo(lx, ly);
            }
            ctx.stroke();
            
            // 2. æ ¸å¿ƒèƒ½é‡ç·š (ä¿æŒç›´ç·šæ„Ÿ)
            ctx.fillStyle = "#ffffff";
            ctx.shadowBlur = 10;
            ctx.shadowColor = "#ffffff";
            ctx.fillRect(a.x, a.y - 1, a.w, 2);

            // 3. æ¬¡ç´šæ•£å°„é›»å¼§ (å¢åŠ ç´°ç¯€èˆ‡ä¸ç©©å®šæ„Ÿ)
            if(Math.random() < 0.7) { // 70% æ©Ÿç‡å‡ºç¾ç¬¬äºŒæ¢ç´°é–ƒé›»
                ctx.beginPath();
                ctx.strokeStyle = "#0099ff"; // æ·±ä¸€é»çš„è—è‰²
                ctx.lineWidth = 1.5;
                ctx.moveTo(a.x, a.y);
                lx = a.x;
                for(let k=0; k < segments; k++) {
                   lx += step;
                   ly = a.y + (Math.random() - 0.5) * 35; // ç¯„åœæ›´å¤§çš„æ•£å°„
                   ctx.lineTo(lx, ly);
                }
                ctx.stroke();
            }

            ctx.restore();
        }

        for (const w of game.goldenWaves) {
             ctx.save();
             ctx.translate(w.x, w.y);
             ctx.rotate(w.angle);
             ctx.fillStyle = "#ffd700";
             ctx.beginPath();
             ctx.arc(0, 0, w.r, 0, Math.PI * 2);
             ctx.fill();
             // æ‹–å°¾æ•ˆæœ
             ctx.fillStyle = "rgba(255, 215, 0, 0.5)";
             ctx.beginPath();
             ctx.moveTo(0, -w.r);
             ctx.lineTo(-60, 0);
             ctx.lineTo(0, w.r);
             ctx.fill();
             ctx.restore();
        }

        for(const atk of game.attackProjectiles) {
            ctx.save();
            ctx.translate(atk.x, atk.y);
            ctx.rotate(atk.rotation);
            ctx.fillStyle = atk.color;
            ctx.beginPath();
            if (atk.type === 'fire') {
                ctx.arc(0, 0, atk.r, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = "#ffff00"; 
                ctx.beginPath(); ctx.arc(-2, -2, atk.r*0.5, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.scale(1.5, 1);
                ctx.arc(0, 0, atk.r, 0, Math.PI*2);
                ctx.fillStyle = "#00ccff";
                ctx.shadowBlur = 15;
                ctx.shadowColor = "#00ccff";
                ctx.fill();
                ctx.fillStyle = "#ffffff";
                ctx.beginPath(); ctx.arc(0, 0, atk.r*0.6, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();
        }

        ctx.font = "bold 24px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        for(const prj of game.wordProjectiles) {
            // è¨­å®šè–èª•è€äººå°ºå¯¸
            const santaW = prj.r * 2.8; // ç¨å¾®åŠ å¯¬ä»¥å®¹ç´é›ªæ©‡
            const santaH = 55; 

            ctx.save();
            ctx.translate(prj.x, prj.y);
            
            // ç¿»è½‰é‚è¼¯ï¼šSVG é è¨­é¢å‘å³å´
            // å¦‚æœ vx < 0 (å‘å·¦é£›)ï¼Œå‰‡æ°´å¹³ç¿»è½‰
            if (prj.vx < 0) {
                 ctx.scale(-1, 1); 
            }
            // ç¹ªè£½åœ–ç‰‡ï¼Œä¸­å¿ƒé»å°é½Š
            ctx.drawImage(assets.santa, -santaW/2, -santaH/2, santaW, santaH);
            ctx.restore();

            // ç¹ªè£½æ–‡å­— (ç™½è‰²)
            ctx.fillStyle = "#ffffff"; 
            ctx.shadowBlur = 3;
            ctx.shadowColor = "rgba(0,0,0,0.8)";
            ctx.fillText(prj.text, prj.x, prj.y + 4); // ç¨å¾®å¾€ä¸‹ç§»ä¸€é»é»
            ctx.shadowBlur = 0;
        }

        for(const g of game.ghosts) {
            ctx.save(); // [ä¿®æ”¹] ä½¿ç”¨ ctx.save() ç¢ºä¿ç‹€æ…‹ä¸å½±éŸ¿å…¶ä»–ç¹ªåœ–
            ctx.globalAlpha = g.alpha;
            
            // [æ–°å¢] å—å‚·é–ƒçˆæ•ˆæœ
            if (g.hitFlash > 0) {
                // ä½¿ç”¨ filter è£½é€ å—å‚·è®Šè‰²æ•ˆæœ
                ctx.filter = "brightness(200%) sepia(100%) hue-rotate(-50deg) saturate(600%)"; 
            }

            const size = g.r * 2.2; 
            ctx.drawImage(assets.ghost, g.x - size/2, g.y - size/2, size, size);
            
            ctx.restore(); // [ä¿®æ”¹] æ¢å¾©ç¹ªåœ–ç‹€æ…‹

            // [æ–°å¢] é¡¯ç¤ºè¡€é‡ (å¦‚æœè¡€é‡å¤§æ–¼ 1)
            if (g.hp > 1) {
                ctx.fillStyle = "#fff";
                ctx.font = "bold 14px sans-serif";
                ctx.shadowColor = "black";
                ctx.shadowBlur = 2;
                ctx.fillText(`HP: ${g.hp}`, g.x, g.y - g.r - 10);
                ctx.shadowBlur = 0;
            }
        }

        if(game.boss && game.boss.hp > 0) {
            const b = game.boss;
            const size = b.r * 2.2;
            
            ctx.save();
            if (b.hitFlash > 0) {
                ctx.globalAlpha = 0.6; 
                ctx.filter = "brightness(200%)";
            }
            
            ctx.drawImage(assets.boss, b.x - size/2, b.y - size/2, size, size);
            ctx.restore();

            if (b.hitFlash > 0) {
                 ctx.strokeStyle = "rgba(255,255,255,0.8)";
                 ctx.lineWidth = 4;
                 ctx.beginPath();
                 ctx.arc(b.x, b.y, b.r + 5, 0, Math.PI*2);
                 ctx.stroke();
            }
        }

        const p = game.player;
        if(p) {
            ctx.save();
            const size = p.w * 1.2;
            ctx.drawImage(assets.player, p.x - size/2, p.y - size/2, size, size);
            ctx.restore();

            if (game.touchTarget) {
               ctx.strokeStyle = "rgba(255,255,255,0.3)";
               ctx.beginPath(); ctx.moveTo(p.x, p.y);
               ctx.lineTo(game.touchTarget.x, game.touchTarget.y); ctx.stroke();
            }
        }

        for(const e of game.effects) {
            ctx.globalAlpha = e.alpha;
            ctx.fillStyle = e.color;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }

        // ç¹ªè£½ HP & Boss è¡€æ¢
        ctx.fillStyle = "#fff";
        ctx.font = "14px sans-serif";
        ctx.textAlign = "left";
        ctx.fillText(`HP: ${game.hp} / ${game.maxHp}`, 20, 30);
        ctx.fillStyle = "#444";
        ctx.fillRect(80, 18, 100, 12);
        ctx.fillStyle = game.hp > 2 ? "#4cd964" : "#ff3b30";
        ctx.fillRect(80, 18, 100 * (game.hp / game.maxHp), 12);

        if (game.level === 2 && game.boss) {
            const b = game.boss;
            const barW = 200;
            const barX = WIDTH/2 - barW/2;
            const barY = 50;
            ctx.fillStyle = "rgba(0,0,0,0.6)";
            ctx.fillRect(barX, barY, barW, 10);
            ctx.fillStyle = "#ff3333";
            ctx.fillRect(barX, barY, barW * (Math.max(0,b.hp) / b.maxHp), 10);
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barW, 10);
            ctx.textAlign = "center";
            ctx.fillStyle = "#fff";
            ctx.fillText("é­”ç‹ HP", WIDTH/2, barY - 5);
        }

        if (game.hitEffectTime > 0) {
            ctx.fillStyle = `rgba(255, 0, 0, ${game.hitEffectTime})`;
            ctx.fillRect(0,0,WIDTH,HEIGHT);
        }
        if (game.flashTime > 0) {
            ctx.fillStyle = `rgba(255, 255, 200, ${game.flashTime})`;
            ctx.fillRect(0,0,WIDTH,HEIGHT);
        }

        if (game.state === "menu") {
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillRect(0,0,WIDTH,HEIGHT);
            ctx.fillStyle = "#fff";
            ctx.font = "30px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("å‹‡è€…é—–å·¨å¤§åŒ–é¬¼å±‹", WIDTH/2, HEIGHT/2);
            ctx.font = "16px sans-serif";
            ctx.fillText("è«‹æŒ‰å·¦æ–¹/ä¸Šæ–¹æŒ‰éˆ•é–‹å§‹", WIDTH/2, HEIGHT/2 + 40);
        }
    }

    function loop(time) {
        const dt = (time - game.lastTime) / 1000;
        game.lastTime = time;
        update(Math.min(dt, 0.1));
        draw();
        requestAnimationFrame(loop);
    }
    game.lastTime = performance.now();
    requestAnimationFrame(loop);
  </script>
</body>

</html>
